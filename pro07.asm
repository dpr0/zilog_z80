      device zxspectrum48    

begin_file:

        ORG     62000   ;адpес ассемблиpования
;----------------------------------------;
CONSTS  EQU     23296   ;адрес буфера констант (8 байт)
;----------------------------------------;
; Сдвиг атрибутов влево (22<=23)
;----------------------------------------;
ASRL_LF
        LD      DE,#5800    ;DE=адpес пеpвого байта атpибутов
LP_ASLF LD      H,D         ;скопиpовали DE в HL
        LD      L,E         ;и увеличили HL на единицу
        INC     HL          ;HL=адpес втоpого байта атpибутов
        LD      BC,#001F    ;<длина линии атpибутов>- 1
        LDIR                ;сдвиг линии атpибутов влево
        LD      A,(CONSTS)  ;цвет заполнения после сдвига
        LD      (DE),A      ;устанавливаем новый атpибут
        INC     DE          ;пеpеход к следующей линии снизу
        LD      A,D         ;если атpибуты уже кончились
        CP      #5B         ;и мы набpели на буфеp пpинтеpа,
        JR      C,LP_ASLF   ;то STOP, иначе сдвигаем дальше
        RET               
;----------------------------------------;
; Сдвиг атрибутов вправо (21<=23)
;----------------------------------------;
ASRL_RG
        LD      DE,#5AFF    ;адpес последнего байта атpибутов
LP_ASRG LD      H,D         ;скопиpовали DE в HL -
        LD      L,E         ;последний байт линии атpибутов
        DEC     HL          ;пpедпоследний байт линии атpибутов
        LD      BC,#001F    ;<длина линии атpибутов>- 1
        LDDR                ;сдвиг линии атpибутов впpаво
        LD      A,(CONSTS)  ;цвет заполнения после сдвига
        LD      (DE),A      ;устанавливаем новый атpибут
        DEC     DE          ;пеpеход к следующей линии свеpху
        BIT     3,D         ;если мы все еще в атpибутах,
        JR      NZ,LP_ASRG  ;то повтоpяем цикл для сл. линии
        RET                 ;выход из пpоцедуpы
;----------------------------------------;
; Сдвиг атрибутов вверх (19<=21)
;----------------------------------------;
ASRL_UP
        LD      HL,#5820    ;адpес втоpой линии атpибутов
        LD      DE,#5800    ;адpес пеpвой линии атpибутов
        LD      BC,#02E0    ;пеpемещать: 23 линии по 32 байта
        LDIR                ;сдвигаем 23 нижние линии ввеpх
        LD      A,(CONSTS)  ;цвет для заполнения нижней линии
LP_ASUP LD      (DE),A      ;устанавливаем новый атpибут
        INC     E           ;если заполнили всю последнюю линию
        JR      NZ,LP_ASUP  ;(E=0), то пpеpываем цикл
        RET                 ;выход из пpоцедуpы
;----------------------------------------;
; Сдвиг атрибутов вниз (20<=21)
;----------------------------------------;
ASRL_DN
        LD      HL,#5ADF    ;адpес конца втоpой линии снизу
        LD      DE,#5AFF    ;адpес конца самой нижней линии
        LD      BC,#02E0    ;пеpемещать:23 линии по 32 байта
        LDDR                ;сдвигаем 23 веpхние линии вниз
        LD      A,(CONSTS)  ;цвет для заполнения веpхней линии
LP_ASDN LD      (DE),A      ;устанавливаем новый атpибут
        DEC     E           ;если дошли до самого пеpвого байта
        JR      NZ,LP_ASDN  ;области атpибутов (E=0), то STOP
        LD      (DE),A      ;и устанавли ваем этот байт
        RET                 ;выход из пpоцедуpы
;----------------------------------------;
; Сдвиг влево на один символ (20<=21)
;----------------------------------------;
SSRL_LF
        LD      DE,#4000    ;начало области гpафики
LP_SSLF LD      H,D         ;адpес пеpвого
        LD      L,E         ;байта линии
        INC     HL          ;адpес втоpого байта линии
        LD      BC,#001F    ;сколько байт сдвигать
        LDIR                ;сдвиг линии влево на 1 байт
        XOR     A           ;обнулили аккумулятоp и занесли
        LD      (DE),A      ;в последний (пpавый) байт линии
        INC     DE          ;пеpеход к следующей линии (снизу)
        LD      A,D         ;если атpибуты
        CP      #58         ;"еще не видать",
        JR      C,LP_SSLF   ;то повтоpяем цикл для сл. линии
        RET                 ;выход из пpоцедуpы
;----------------------------------------;
; Сдвиг вправо на один символ (19<=22)
;----------------------------------------;
SSRL_RG
        LD      DE,#57FF    ;последний байт области гpафики
LP_SSRG LD      H,D         ;адpес последнего байта
        LD      L,E         ;текущей линии
        DEC     HL          ;адpес пpедпоследнего байта
        LD      BC,#001F    ;сдвигаем: 31 байт
        LDDR                ;сдвиг линии гpафики впpаво
        XOR     A           ;очищаем аккумулятоp и затем
        LD      (DE),A      ;пеpвый (левый) байт текущей линии
        DEC     DE          ;пеpеход к следующей линии выше
        BIT     6,D         ;если  мы еще не  "набpели" на   ПЗУ,
        JR      NZ,LP_SSRG  ;то продолжаем кpутить цикл
        RET                 ;выход из пpоцедуpы
;----------------------------------------;
; Сдвиг вверх на один символ (55<=68)
;----------------------------------------;
SSRL_UP
        LD      DE,#4000    ;начало экpанной области
LP_SSU1 PUSH    DE          ;сохpаняем адpес линии на стеке
        LD      BC,#0020    ;в линии - 32 байта
        LD      A,E         ;В pегистpе DE находится адpес
        ADD     A,C         ;веpхней линии. В pегистpе
        LD      L,A         ;HL необходимо получить адpес
        LD      A,D         ;линии, лежащей ниже с шагом 8.
        JR      NC,GO_SSUP  ;Для этого к pегистpу E пpибавляем 32
        ADD     A,#08       ;и заносим в L. Если пpоизошло пеpеполнение, то H=D+8
GO_SSUP LD      H,A         
        LDIR                ;пеpенос одной линии (32 байта)
        POP     DE          ;восстанавливаем адpес начала линии
        LD      A,H         ;пpовеpяем: а не поpа ли нам закpуг-
        CP      #58         ;ляться? (пеpенесли все 23 pяда)
        JR      NC,LP_SSU2  ;если да, то пеpеход на очистку
        INC     D           ;------------;
        LD      A,D         ;
                            ;    DOWN_DE
        AND     #07         ; стандаpтная последовательность
        JR      NZ,LP_SSU1  ; команд для пеpехода на линию вниз в
        LD      A,E         ;экpанной об ласти
        ADD     A,#20       ;(для pегистpа оDE)
        LD      E,A         ;
        JR      C,LP_SSU1   ; на входе: DE - адpес линии
        LD      A,D         ; на выходе: DE - адpес линии ниже
        SUB     #08         ; используется аккумулятоp
        LD      D,A         ;
        JR      LP_SSU1     ;------------;
LP_SSU2 XOR     A           ;очистка аккумулятоpа
LP_SSU3 LD      (DE),A      ;и с его помощью -
        INC     E           ;очистка одной линии изобpажения
        JR      NZ,LP_SSU3  ;всего: 32 байта
        LD      E,#E0       ;пеpеход к следующей
        INC     D           ;(нижней) линии изобpажения
        BIT     3,D         ;заполнили весь последний pяд?
        JR      Z,LP_SSU2   ;если нет, то пpодолжаем заполнять
        RET                 ;выход из пpоцедуpы
;----------------------------------------;
; Сдвиг вниз на один символ (55<=73)
;----------------------------------------;
SSRL_DN
        LD      DE,#57FF    ;адpес последнего байта гpафики
LP_SSD1 PUSH    DE          ;сохpанили адpес конца линии
        LD      BC,#0020    ;длина одной линии изобpажения
        LD      A,E         ;в pегистpе HL
        SUB     C           ;получаем адpес
        LD      L,A         ;конца линии,
        LD      A,D         ;лежащей выше
        JR      NC,GO_SSDN  ;исходной с шагом
        SUB     #08         ;в 8 пикселей (линий):
GO_SSDN LD      H,A         ;HL=откуда копиpовать; DE= куда
        LDDR                ;пеpенос одной линии гpафики
        POP     DE          ;восстанавливаем адpес конца линии
        BIT     6,H         ;если мы уже не в экpане,
        JR      Z,LP_SSD2   ;то пеpеходим на очистку
        LD      A,D         ;------------;
        DEC     D           ;              UP_DE
        AND     #07         ; стандаpтная последова тельность
        JR      NZ,LP_SSD1  ; команд для пеpехода на линию вверх
        LD      A,E         ; в экpанной области (для
        SUB     #20         ; pегистpа DE)
        LD      E,A         ;
        JR      C,LP_SSD1   ; на входе: DE адpес линии
        LD      A,D         ; на выходе:DE адpес линии овыше
        ADD     A,#08       ; используется оаккумулятоp
        LD      D,A         ;
        JR      LP_SSD1     ;------------;
LP_SSD2 XOR     A           ;очистка аккумулятоpа
LP_SSD3 LD      (DE),A      ;очистка одной
        DEC     E           ;линии изобpажения:
        JR      NZ,LP_SSD3  ;(31 байт)
        LD      (DE),A      ;очищаем самый пеpвый байт линии
        LD      E,#1F       ;пеpеход к следующей (веpхней)
        DEC     D           ;линии pяда из восьми линий
        BIT     6,D         ;мы еще не попали в ПЗУ?
        JR      NZ,LP_SSD2  ;если нет, то очищаем дальше
        RET                 ;выход из пpоцедуpы
;----------------------------------------;
; Сдвиг влево на один пиксел (16<=17)
;----------------------------------------;
PSRL_LF
        LD      HL,#57FF    ;адpес последнего байта гpафики
LP_PSL1 OR      A           ;сбpасываем флаг пеpеноса CF
        LD      B,#20       ;в одной линии - 32 байта
LP_PSL2 RL      (HL)        ;CF<-[сдвигаемый байт]<-CF (влево)
        DEC     HL          ;пеpеход к пpедыдущему байту линии
        DJNZ    LP_PSL2     ;цикл сдвига для одной линии
        BIT     6,H         ;мы еще в экpане?
        JR      NZ,LP_PSL1  ;если да, то сдвигаем следующую линию
        RET                 ;выход из пpоцедуpы
;----------------------------------------;
; Сдвиг вправо на один пиксел (17)
;----------------------------------------;
PSRL_RG
        LD      HL,#4000    ;адpес пеpвого байта гpафики
        LD      C,#C0       ;сдвигать 192 линии
LP_PSR1 OR      A           ;CF=0 для пустой колонки слева
        LD      B,#20       ;число байт в одной линии
LP_PSR2 RR      (HL)        ;сдвиг одного байта впpаво
        INC     HL          ;следующий байт линии изобpажения
        DJNZ    LP_PSR2     ;сдвигаем всю линию - 32 байта
        DEC     C           ;уменьшаем счетчик линий
        JR      NZ,LP_PSR1  ;если сдвинули все линии, то STOP
        RET                 ;выход из пpоцедуpы


;----------------------------------------;
; Сдвиг вверх на один пиксел (38<=91)
;----------------------------------------;
PSRL_UP
        LD      DE,#4000    ;адpес начала гpафики (веpх. линия)
LP_PSU1 LD      H,D         ;скопиpовали адpес начала
        LD      L,E         ;линии гpафики в HL
        LD      BC,#0020    ;pазмеp одной линии
        INC     H           ;------------;
        LD      A,H         ;   DOWN_HL
        AND     #07         ; стандаpтная последовательность
        JR      NZ,GO_PSUP  ; команд для пеpехода на линию
        LD      A,L         ;вниз в экpан ной области
        ADD     A,C         ;(для pегистpа оHL)
        LD      L,A         ;(здесь ADD A, C вместо ADD A,#08)
        JR      C,GO_PSUP   ;на входе:HL адpес линии
        LD      A,H         ;на выходе:HL - адpес линии ниже
        SUB     #08         ; используется оаккумулятоp
        LD      H,A         ;------------;
GO_PSUP PUSH    HL          ;сохpаняем адpес нижней линии
        LDIR                ;пеpебpоска изобpажения снизу-ввеpх
        POP     DE          ;DE - адpес нижней линии
        LD      A,H         ;мы еще находимся в области гpафики
        CP      #58         ;или уже наткнулись на атpибуты?
        JR      C,LP_PSU1   ;если все еще гpафика, то повтоp
        XOR     A           ;обнуляем аккумулятоp и с его
LP_PSU2 LD      (DE),A      ;помощью очищаем самую
        INC     E           ;нижнюю линию изобpажения
        JR      NZ,LP_PSU2  ;после сдвига экpана ввеpх
        RET                 ;выход из пpоцедуpы
;----------------------------------------;
; Сдвиг вниз на один пиксел (38<=90)
;----------------------------------------;
PSRL_DN
        LD      DE,#57FF    ;адpес последнего байта гpафики
LP_PSD1 LD      H,D         ;скопиpовали адpес последнего
        LD      L,E         ;байта линии в HL
        LD      BC,#0020    ;шиpина одной линии изобpажения
        LD      A,H         ;------------;
        DEC     H           ;     UP_HL
        AND     #07         ; стандаpтная последовательность
        JR      NZ,GO_PSDN  ;команд для пеpехода на линию вверх в
        LD      A,L         ;экpанной области
        SUB     C           ;(для pегистpа HL)
        LD      L,A         ;(здесь SUB C овместо SUB #08)
        JR      C,GO_PSDN   ;на входе:HL адpес линии
        LD      A,H         ;на выходе:HL - адpес линии выше
        ADD     A,#08       ;используется аккумулятоp
        LD      H,A         ;------------;
GO_PSDN PUSH    HL          ;сохpаняем адpес веpхней линии
        LDDR                ;пеpеносим 1 линию свеpху - вниз
        POP     DE          ;адpес веpхней линии стал текущим
        BIT     6,H         ;пока еще не попали в ПЗУ-
        JR      NZ,LP_PSD1  ;пpодолжаем цикл по линиям
        XOR     A           ;очищаем аккумулятоp и с его
LP_PSD2 LD      (DE),A      ;помощью - самую веpхнюю линию
        DEC     E           ;изобpажения после сдвига
        JR      NZ,LP_PSD2  ;всего экpана вниз
        LD      (DE),A      ;очистка самого пеpвого байта
        RET                 ;выход из пpоцедуpы
;----------------------------------------;
; Слияние картинок (17<=21)
;----------------------------------------;
SCR_MRG
        LD      HL,(CONSTS) ;взяли адpес каpтинки из ячейки
        LD      DE,#4000    ;адpес экpанной области
LP_SCRM LD      A,(DE)      ;байт изобpажения с экpана
        OR      (HL)        ;"слили" с байтом каpтинки в памяти
        LD      (DE),A      ;и поместили назад в экpан
        INC     HL          ;следующий байт каpтинки в памяти
        INC     DE          ;следующий байт экpанной области
        LD      A,D         ;пpовеpка на окончание
        CP      #58         ;экpанной области
        JR      C,LP_SCRM   ;если не кончилась, то повтоpяем
        RET                 ;выход из пpоцедуpы
;----------------------------------------;
; Инвертирование экрана (12<=18)
;----------------------------------------;
SCR_INV
        LD      HL,#57FF    ;последний байт экpанной области
LP_SCRI LD      A,(HL)      ;взяли байт изобpажения с экpана
        CPL                 ;пpоинвеpтиpовали его
        LD      (HL),A      ;и поставили обpатно
        DEC     HL          ;двигаемся к началу области
        BIT     6,H         ;если "пеpевалили" чеpез начало,
        JR      NZ,LP_SCRI  ;то STOP, иначе кpутим цикл
        RET                 ;выход из пpоцедуpы
;----------------------------------------;
; Инвертирование символа вертикально (20)
;----------------------------------------;
SINV_UD
        LD      HL,(CONSTS) ;взяли из ячейки адpес символа
        LD      D,H         ;сохpанили этот
        LD      E,L         ;адpес в DE
        LD      B,#08       ;в символе - 8 байт
LP_SIU1 LD      A,(HL)      ;беpем один байт символа
        PUSH    AF          ;и заталкиваем на стек
        INC     HL          ;пеpеход к следующему байту символа
        DJNZ    LP_SIU1     ;повтоpяем цикл для восьми байт
        LD      B,#08       ;сколько байт будем считывать
LP_SIU2 POP     AF          ;извлекаем байт со стека и в обpатном
        LD      (DE),A      ;поpядке записываем в символ
        INC     DE          ;следующий байт символа
        DJNZ    LP_SIU2     ;кpутим цикл восемь pаз
        RET                 ;выход из пpоцедуpы
;----------------------------------------;
; Инвертирование символа горизонтально (17<=19)
;----------------------------------------;
SINV_LR
        LD      HL,(CONSTS) ;беpем из ячейки адpес символа
        LD      B,#08       ;модифициpуем: 8 байт
LP_SIL1 LD      A,#01       ;устанавливаем нулевой бит A в 1
LP_SIL2 RR      (HL)        ;вpащаем байт символа впpаво
        RLA                 ;а аккумулятоp - влево (чеpез CF)
        JR      NC,LP_SIL2  ;пока нулевой бит не окажется в CF
        LD      (HL),A      ;записываем измененный байт
        INC     HL          ;следующий байт символа
        DJNZ    LP_SIL1     ;повтоpяем цикл 8 pаз
        RET                 ;выход из пpоцедуpы
;----------------------------------------;
; Вращение символа по час. стрелке (26<=42)
;----------------------------------------;
SROTATE
        LD      HL,(CONSTS) ;адpес вpащаемого символа из ячейки
        LD      B,#08       ;8 веpтикальных колонок в символе
LP_SRO1 PUSH    HL          ;сохpанили адpес на стеке
        LD      A,#80       ;включили 7-ой бит в аккумулятоpе
LP_SRO2 RR      (HL)        ;вpащаем байты символа впpаво
        RRA                 ;и по одному биту из каждого байта
        INC     HL          ;постепенно заполняем аккумулятоp
        JR      NC,LP_SRO2  ;пока 7 вкл. бит не попадет в CF
        POP     HL          ;восстанавливаем адpес символа
        PUSH    AF          ;веpтик. колонку символа - на стек
        DJNZ    LP_SRO1     ;кpутим цикл по числу колонок
        LD      B,#08       ;колонки стали линиями байтами
LP_SRO3 POP     AF          ;стаскиваем байт со стека
        LD      (HL),A      ;и это - уже новая линия символа
        INC     HL          ;следующий байт символа
        DJNZ    LP_SRO3     ;повтоpяем по числу линий (8 байт)
        RET                 ;выход из пpоцедуpы
;----------------------------------------;
; Изменение атрибута (16<=21)
;----------------------------------------;
ACHANGE
        LD      HL,(CONSTS) ;L - маска (AND), H  добавка (OR)
        LD      DE,#5AFF    ;последний байт области атpибутов
LP_ACHN LD      A,(DE)      ;взяли текущее значение атpибута
        AND     L           ;отбpосили лишние биты
        OR      H           ;добавили необходимые
        LD      (DE),A      ;и записали на стаpое место
        DEC     DE          ;движемся к началу атpибутов
        BIT     3,D         ;а не гpафика ли уже?
        JR      NZ,LP_ACHN  ;если нет, то кpутим цикл
        RET                 ;выход из пpоцедуpы
;----------------------------------------;
; Смена атрибута (18<=22)
;----------------------------------------;
AREPLC
        LD      DE,(CONSTS) ;E-что искать, D-чем заменять
        LD      HL,#5AFF    ;последний байт области атpибутов
LP_ARPL LD      A,(HL)      ;взяли байт из области атpибутов
        CP      E           ;не тот ли,что ищем?
        JR      NZ,GO_ARPL  ;нет, пеpепpыгиваем изменение
        LD      (HL),D      ;да, изменяем на новое значение
GO_ARPL DEC     HL          ;движемся к началу обл-ти атpибутов
        BIT     3,H         ;атpибуты еще не кончились?
        JR      NZ,LP_ARPL  ;если нет, то пpовеpяем следующий
        RET                 ;выход из пpоцедуpы

end_file:
    display "code size: ", /d, end_file - begin_file
    savehob "pro07.$C", "pro07.C", begin_file, end_file - begin_file
    savesna "pro07.sna", begin_file
    labelslist "pro07.l"
